
////////////////////////////////////////////////////////////////////////////////
// ПЕРЕМЕННЫЕ МОДУЛЯ
//

Перем ДопДанные Экспорт; // Соответствие
Перем ВременныеФайлы;


// Пространства имен (xmlns)
Перем xmlnsXML;
перем xmlnsV8XDTO;
Перем xmlnsОписанияТиповКлассификаторов;
Перем xmlnsКлассификатор;
Перем xmlnsНормАкты;

Перем ФабрикаXDTOКлассификаторов;
Перем МассивОбщихПакетовXDTO;
Перем xdtoТипыКлассификаторов;

Перем СерверОбновлений;
Перем ПутьНаСервереОбновлений;

Перем Соединение;

Перем МетаданныеКонфигурации; // = Метаданные
Перем СвойстваОбъектовМетаданных; // = Метаданные.СвойстваОбъектов

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ ПОЛУЧЕНИЯ ИСПОЛЬЗУЕМЫХ ОБЪЕКТОВ XDTO
//

// Функция создает объект XDTO из XML.
//
// Параметы:
//  XML          - Строка, ЧтениеXML, ЧтениеFastInfoset, ЧтениеУзловDOM;
//                 источник – строка XML или уже созданный читатель;
//  Фабрика      - ФабрикаXDTO; фабрика, содержащая пакеты типов, которые
//                 будем читать;
//  ТипURI       - Строка; URI пространства имен типа, объект которого мы
//                 собрались читать;
//  ТипИмя       - Строка; локальное имя типа считываемого объекта.
//
// Возвращаемое значение:
//  ОбъектXDTO.
//
Функция xdtoПрочитать(Знач XML,
                      Знач Фабрика,
                      Знач ТипURI = "",
                      Знач ТипИмя = "")
	Если Не ПустаяСтрока(ТипИмя) Тогда
		Тип = Фабрика.Тип(ТипURI, ТипИмя)
	Иначе
		Тип = Неопределено
	КонецЕсли;
	Если ТипЗнч(XML) = Тип("Строка") Тогда
		ЧтениеXML = Новый ЧтениеXML;
		ЧтениеXML.УстановитьСтроку(XML)
	Иначе
		ЧтениеXML = XML;
	КонецЕсли;
	Возврат Фабрика.ПрочитатьXML(ЧтениеXML, Тип);
КонецФункции // ПрочитатьXDTO() 

// Функция формирует, если нужно, и возвращает фабрику XDTO, содержащую пакеты
// типов пространства имен {xmlnsКлассификатор}. Объект XDTO типа
// {http://v8.1c.ru/8.1/xdto}Model – модель типов – считывается из макета.
//
// Возвращаемое значение:
//  ФабрикаXDTO.
//
Функция ФабрикаXDTOКлассификаторов()
	Если ФабрикаXDTOКлассификаторов = Неопределено Тогда
		Если МассивОбщихПакетовXDTO = Неопределено Тогда
			МассивОбщихПакетовXDTO = Новый Массив;
			xdtoМодельXDTOТипов = xdtoПрочитать(ПолучитьМакет("МодельXDTO").ПолучитьТекст(),
				ФабрикаXDTO,
				xmlnsV8XDTO, "Model");
			Для Каждого xdtoПакет Из xdtoМодельXDTOТипов.Package Цикл
				МассивОбщихПакетовXDTO.Добавить(xdtoПакет);
			КонецЦикла;
		Иначе
			xdtoМодельXDTOТипов = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип(xmlnsV8XDTO, "Model"));
			Для Каждого xdtoПакет Из МассивОбщихПакетовXDTO Цикл
				xdtoМодельXDTOТипов.Package.Добавить(xdtoПакет);
			КонецЦикла;
		КонецЕсли;
		ФабрикаXDTOКлассификаторов = Новый ФабрикаXDTO(xdtoМодельXDTOТипов);
	КонецЕсли;
	Возврат ФабрикаXDTOКлассификаторов
КонецФункции // ФабрикаXDTOКлассификаторов()

// Функция получает объект-список поддерживаемых конфигурацией типов
// классификаторов.
//
// Возвращаемое значение:
//  ОбъектXDTO типа {xmlnsОписанияТиповКлассификаторов}ClassifierTypeListType.
// Содержит свойства: ТипыКлассификаторов – список (<classifier-type>).
//
Функция xdtoТипыКлассификаторов()
	Если xdtoТипыКлассификаторов = Неопределено Тогда
		Попытка
			МакетТипов = ПолучитьОбщийМакет("ТипыКлассификаторов");
		Исключение
			МакетТипов = ПолучитьМакет("ТипыКлассификаторов");
		КонецПопытки;
		xdtoТипыКлассификаторов = xdtoПрочитать(МакетТипов.ПолучитьТекст(),
			ФабрикаXDTOКлассификаторов(),
			xmlnsОписанияТиповКлассификаторов, "ClassifierTypeListType");
	КонецЕсли;
	Возврат xdtoТипыКлассификаторов;
КонецФункции // xdtoТипыКлассификаторов() 

// Функция возвращает объект-описатель типа классификатора.
//
// Параметры:
//  Идентификатор - Строка; идентификатор типа.
//
// Возвращаемое значение:
//  ОбъектXDTO типа {xmlnsОписанияТиповКлассификаторов}ClassifierTypeType.
// Содержит свойства: xmlid – идентификатор (атрибут
// {http://www.w3.org/XML/1998/namespace}id), ИмяСправочника – строка
// (<catalog-name>), ИмяРеквизитаПолнНаименование – строка
// (<full-name-property>). 
//  Неопределено, если тип не найден.
//
Функция xdtoТипКлассификатора(Идентификатор) Экспорт
	Попытка
		Возврат xdtoТипыКлассификаторов().Получить("ТипыКлассификаторов[xmlid='" + Идентификатор + "']");
	Исключение
		Возврат Неопределено
	КонецПопытки;
КонецФункции // xdtoПолучитьОписаниеТипаКлассификатора() 

////////////////////////////////////////////////////////////////////////////////
// СЕРВИСНЫЕ ПРОЦЕДУРЫ
//

#Если Клиент Тогда

// Получает полное имя каталога информационной базы.
//
// Возвращаемое значение: 
//  Строка. Полное имя каталога информационной базы.
//
Функция ПолучитьКаталогИБ() Экспорт

	СтрокаСоединения = СтрокаСоединенияИнформационнойБазы();
	П = Найти(НРег(СтрокаСоединения), "file=");
	Если П <> 0 Тогда
		КаталогИБ = Сред(СтрокаСоединения, П + 5);
		// отсечем лишнее
		Если Лев(КаталогИБ, 1) = """" Тогда
			КаталогИБ = Сред(КаталогИБ, 2);
			Маркер = """";
		Иначе
			Маркер = ";"
		КонецЕсли; 
		П = Найти(КаталогИБ, Маркер);
		Если П <> 0 Тогда
			КаталогИБ = Лев(КаталогИБ, П - 1);
		КонецЕсли;
		
		Файл = Новый Файл(КаталогИБ);
		Если Файл.Существует()
		   И Файл.ЭтоКаталог() Тогда
			Возврат Файл.ПолноеИмя;
		КонецЕсли;
	КонецЕсли;
	Возврат "";

КонецФункции

// Определяет расположение акталога шаблонов информационных баз
//
// Возвращаемое значение:
//   Путь к папке tmplts
//
Функция ОбщийКаталогШаблонов() Экспорт

	Попытка
		Оболочка = Новый COMObject("wScript.Shell");
		КаталогДанныхПриложений = Оболочка.SpecialFolders.Item("AppData");
	Исключение
		Возврат ""
	КонецПопытки;
	
	Если Не ЗначениеЗаполнено(КаталогДанныхПриложений) Тогда 
		Возврат "" 
	КонецЕсли;
	
	КаталогШаблонов = "";
	СисИнфо 		= Новый СистемнаяИнформация;
	ЭлементыВерсии 	= РазложитьСтрокуВМассивПодстрок(СисИнфо.ВерсияПриложения,".");
	
	// Определение текущей версии приложения.
	Если (Число(ЭлементыВерсии[0]) = 8 И Число(ЭлементыВерсии[1]) >= 2) ИЛИ (Число(ЭлементыВерсии[0]) > 8) Тогда
		
		КаталогПоУмолчанию = Новый Файл(КаталогДанныхПриложений + "\1C\1Cv82\tmplts\");
		Если КаталогПоУмолчанию.Существует() Тогда
			КаталогПоУмолчанию = КаталогПоУмолчанию.ПолноеИмя;
		Иначе
			КаталогПоУмолчанию = "";
		КонецЕсли;
		
		ФайлКонфигурации = Новый Файл(КаталогДанныхПриложений + "\1C\1CEStart\1CEStart.cfg");
		Если Не ФайлКонфигурации.Существует() Тогда
			Возврат КаталогПоУмолчанию;
		КонецЕсли;
		
		Попытка
			// Чтение файла настройки.
			Текст = Новый ЧтениеТекста(ФайлКонфигурации.ПолноеИмя, КодировкаТекста.UTF16);
		Исключение
			// может не быть прав на файл.
			Возврат КаталогПоУмолчанию;
		КонецПопытки;
		
		Стр 			= "";
		КаталогШаблонов = "";
		
		Пока Стр <> Неопределено Цикл
			
			Стр = Текст.ПрочитатьСтроку();
			Если Стр = Неопределено Тогда
				Прервать;
			КонецЕсли; 
			Если Найти(ВРег(Стр), ВРег("ConfigurationTemplatesLocation")) = 0 Тогда
				Продолжить;
			КонецЕсли; 
			ПозицияРазделителя = Найти(Стр, "=");
			Если ПозицияРазделителя = 0 Тогда
				Продолжить;
			КонецЕсли; 
			
			КаталогШаблонов = СокрЛП(Сред(Стр, ПозицияРазделителя + 1));
			
		КонецЦикла; 
		
		Если ПустаяСтрока(КаталогШаблонов) Тогда
			Возврат КаталогПоУмолчанию;
		КонецЕсли;
		
	Иначе	
		
		КаталогПоУмолчанию = Новый Файл(КаталогПрограммы() + "\tmplts");
		Если КаталогПоУмолчанию.Существует() Тогда
			КаталогПоУмолчанию = КаталогПоУмолчанию.ПолноеИмя;
		Иначе
			КаталогПоУмолчанию = "";
		КонецЕсли;
		
		ФайлКонфигурации = Новый Файл(КаталогДанныхПриложений + "\1C\1Cv8"+ЭлементыВерсии[1]+"\v8cscadr.lst");
		
		Если ФайлКонфигурации.Существует() Тогда
			
			КаталогШаблонов = "";
			ЧтениеТекста = Новый ЧтениеТекста;
			ЧтениеТекста.Открыть(ФайлКонфигурации.ПолноеИмя,КодировкаТекста.Системная,,, Ложь);
			
			С = ЧтениеТекста.ПрочитатьСтроку();
			Пока С <> Неопределено Цикл
				С = СокрЛП(С);
				Если НРег(Лев(С, 7)) = "file://" Тогда
					КаталогШаблонов = СокрЛ(Сред(С, 8));
					Прервать;
				КонецЕсли;
			КонецЦикла;
			
			Если КаталогШаблонов = "" Тогда
				Возврат КаталогПоУмолчанию; 
			КонецЕсли;
			
		Иначе
			Возврат КаталогПоУмолчанию;
		КонецЕсли;		
	КонецЕсли;

	Возврат КаталогШаблонов;
	
КонецФункции // ОбщийКаталогШаблонов()

// Получает полное имя каталога шаблонов.
//
// Возвращаемое значение: 
//  Строка. Полное имя каталога шаблонов.
//
Функция ПолучитьКаталогШаблонов() Экспорт

	Попытка
		КаталогШаблонов = ОбщийКаталогШаблонов();
	Исключение
		Возврат "";
	КонецПопытки;
	
	Если КаталогШаблонов = "" Тогда
		Возврат ""; 
	КонецЕсли;
	
	МетаданныеКонфигурации = Метаданные;
	
	КаталогШаблоновКонфигурации = "";
	ИдКонфигурации = МетаданныеКонфигурации.Имя;
	
	Если ИдКонфигурации = "УправлениеПроизводственнымПредприятием" Тогда
		КаталогШаблоновКонфигурации = "Enterprise"
	ИначеЕсли ИдКонфигурации = "КомплекснаяАвтоматизация" Тогда
		КаталогШаблоновКонфигурации = "ARAutomation"
	КонецЕсли;
	
	Если КаталогШаблоновКонфигурации = "" Тогда
		Возврат ""
	КонецЕсли;
		
	ТекРелиз = МетаданныеКонфигурации.Версия;
	ПерваяТочка = Найти(ТекРелиз, ".");
	ВтораяТочка = ПерваяТочка + Найти(Сред(ТекРелиз, ПерваяТочка) + 1, ".");
	ТекРедакция = СтрЗаменить(Лев(ТекРелиз, ВтораяТочка), ".", "_");
	ПозНомераРелиза = СтрДлина(ТекРедакция) + 2;
	
	КаталогиРедакции = НайтиФайлы(КаталогШаблонов + "\1c\" + КаталогШаблоновКонфигурации, ТекРедакция + "*");
	
	ПоследняяСборка = -1;
	Результат = "";
	
	Для Каждого Каталог Из КаталогиРедакции Цикл
		Если Не Каталог.ЭтоКаталог() Тогда
			Продолжить
		КонецЕсли;
		
		НомерРелизаСборки = Сред(Каталог.Имя, ПозНомераРелиза);
		П = Найти(НомерРелизаСборки, "_");
		Если П = 0 Тогда
			Продолжить
		КонецЕсли;
		
		Сборка = Число(Лев(НомерРелизаСборки, П - 1)) * 1000 + Число(Сред(НомерРелизаСборки, П + 1));
		
		Если Сборка > ПоследняяСборка Тогда
			ПоследняяСборка = Сборка;
			Результат = Каталог.ПолноеИмя;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции // ПолучитьКаталогШаблонов()

Функция РазложитьСтрокуВМассивПодстрок(Знач Стр, Разделитель = ",") Экспорт
	Возврат СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Стр, Разделитель);
КонецФункции // глРазложить

#КонецЕсли

// Получает символы готовых и неготовых к чтению устройств чтения.
//
// Параметры:
//  Готовые      - Строка. Выходной параметр в который помещаются символы 
//                 готовых к чтению устройств.
//  Неготовые    - Строка. Выходной параметр в который помещаются символы 
//                 неготовых к чтению устройств.
//
Процедура ОпределитьУстройстваЧтенияКД(Готовые, Неготовые = "") Экспорт
	Готовые = ""; Неготовые = "";
	Попытка
		ОбъектФС = Новый COMObject("Scripting.FileSystemObject");
		Диски = ОбъектФС.Drives;
		Для Каждого Диск Из Диски Цикл
			Если Диск.DriveType = 4 Тогда
				Если Диск.IsReady Тогда
					Готовые = Готовые + Диск.DriveLetter;
				Иначе
					Неготовые = Неготовые + Диск.DriveLetter;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	Исключение
		Возврат;
	КонецПопытки;
КонецПроцедуры 

// Заполняет список локальных каталогов, из которых могут быть 
// загружены классификаторы.
//
Процедура ЗаполнитьЛокальныеКаталогиПоУмолчанию() Экспорт

	#Если Клиент Тогда
	КаталогШаблонов = ПолучитьКаталогШаблонов();
	Если КаталогШаблонов <> ""
	   И ЛокальныеКаталоги.НайтиПоЗначению(КаталогШаблонов) = Неопределено Тогда
		ЛокальныеКаталоги.Добавить(КаталогШаблонов,, Истина);
	КонецЕсли;
	КаталогИБ = ПолучитьКаталогИБ();
	Если КаталогИБ <> ""
	   И ЛокальныеКаталоги.НайтиПоЗначению(КаталогИБ) = Неопределено Тогда
		ЛокальныеКаталоги.Добавить(КаталогИБ,, Истина);
	КонецЕсли;
	#КонецЕсли
	
КонецПроцедуры

Функция ПолучитьТаблицуСсылок(ИмяСправочника, Владелец)
	
	МД = МетаданныеКонфигурации.Справочники.Найти(ИмяСправочника);
	Иерархический    = МД.Иерархический;
	БываютГруппы     = Иерархический
		И МД.ВидИерархии =
			 СвойстваОбъектовМетаданных.
			ВидИерархии.
			ИерархияГруппИЭлементов;
	НуженРодитель    = Иерархический
		И МД.СерииКодов =
			СвойстваОбъектовМетаданных.
			СерииКодовСправочника.
			ВПределахПодчинения;
	НуженВладелец    = МД.СерииКодов <>
			СвойстваОбъектовМетаданных.
			СерииКодовСправочника.
			ВоВсемСправочнике;
			
	Запрос = Новый Запрос;
	ТекстЗапроса = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
	               |	Спр.Код КАК Код,
	               |	Спр.Ссылка КАК Ссылка,
	               |	Спр.ПометкаУдаления КАК ПометкаУдаления,
	               |	&Родитель,
	               |	&ТекЭтоГруппа КАК ТекЭтоГруппа
	               |ИЗ
	               |	&Справочник КАК Спр";
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&Справочник", "Справочник." + ИмяСправочника);
	Если БываютГруппы Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ТекЭтоГруппа", "Спр.ЭтоГруппа")
	Иначе
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ТекЭтоГруппа", "ЛОЖЬ")
	КонецЕсли;
	Если НуженРодитель Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&Родитель,", "Спр.Родитель КАК Родитель,")
	Иначе
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&Родитель,", "");
	КонецЕсли;
	Если НуженВладелец Тогда
		ТекстЗапроса = ТекстЗапроса + "
			|ГДЕ
			|	Спр.Владелец = &Владелец";
		Запрос.УстановитьПараметр("Владелец", Владелец);
	КонецЕсли;
	
	Запрос.Текст = ТекстЗапроса;
	Результат = Запрос.Выполнить().Выгрузить();
	Результат.Индексы.Добавить("Код");
	Если НуженРодитель Тогда
		Результат.Индексы.Добавить("Родитель");
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // ПолучитьТаблицуСсылок()

// Выполнение соединения с сервером обновлений.
//
// Возвращаемое значение:
//  HTTPсоединение
//
Процедура СоединениеССерверомОбновлений(Сервер, Соединение, Аутентификация = Ложь, Защищенное = Ложь)
	
	Если Соединение <> Неопределено И Соединение.Сервер = Сервер Тогда
		Возврат;
	КонецЕсли; 
	
	// Установка параметров прокси-сервера.
	Если ПроксиСерверТребуетАутентификации Тогда
		ПроксиСервер = Новый ИнтернетПрокси();
		ПроксиСервер.Пользователь = ПользовательПроксиСервера;
		ПроксиСервер.Пароль       = ПарольПроксиСервера;
	КонецЕсли;
	
	// Создание HTTP-соединения с сервером обновлений.
	
	Соединение = Новый HTTPСоединение(Сервер,
	                                  ,
	                                  ?(Аутентификация, КодПользователяСервераОбновлений, Неопределено),
	                                  ?(Аутентификация, ПарольСервераОбновлений, Неопределено),
	                                  ?(ПроксиСерверТребуетАутентификации, ПроксиСервер, Неопределено),
	                                  Защищенное);
	
КонецПроцедуры // СоединениеССерверомОбновлений()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ ЗАПИСИ СПРАВОЧНИКОВ
//

// Процедура записи иерархической коллекции в справочник (рекурсивная).
//
// Параметры:
//  Коллекция    - КоллекцияСтрокДереваЗначений, ТаблицаЗначений, СписокXDTO;
//                 коллекция, элементы которой содержат свойства позиции
//                 классификатора;
//  ЕстьПометка  - Булево; означает, что у эл. колл. есть свойство Пометка,
//                 которое нужно проверять, иначе – безусловно;
//  ЕстьСтроки   - Булево; означает, что у эл. колл. есть свойство-коллекция
//                 Строки, и нужнен рекурсивный вызов для него;
//  ЕстьЭлементы - Булево; означает, что у эл. колл. есть свойство-коллекция
//                 Элементы, и нужнен рекурсивный вызов для него (коллекция не
//                 иерархическая);
//  ЭтоОбъектXDTO - Булево; если Истина, то Коллекция есть СписокXDTO;
//  ЭтоГруппа    - Булево, Неопределено; если Неопределено, значит у эл. колл.
//                 есть свойство ЭтоГруппа, его надо проверять;
//  ИскатьПоКоду - ПСОМД.СерииКодовСправочника; если ЕстьСсылка = Ложь,
//                 пытаться найти соответствующий эл. справочника по коду;
//  ПолнНаимен   - Строка; имя реквизита справочника, хранящего полное
//                 наименование; если пустая – не устанавливать;
//  Родитель     - Ссылка, Неопределено; ссылка на элемент справочника –
//                 родителя элементов, создаваемых на основе коллекции;
//                 для неиерархического справочника – Неопределено,
//                 для корневых элементов – пустая ссылка;
//  Владелец     - Ссылка, Неопределено; ссылка на элемент справочника –
//                 владельца, для неподчиненного – Неопределено;
//  Менеджер     - соответствующий СправочникМенеджер;
//  РазмерТранзакции - 0 или кол-во элементов, после обработки которого
//                 нужно фиксировать транзакцию;
//  Прогресс     - Число; инкрементируемая переменная (реквизит формы,
//                 для обновления прогресс-бара).
//
Процедура ЗаписатьКоллекциюВСправочник(Коллекция,
	ЕстьПометка, ЕстьСтроки, ЕстьЭлементы, ЭтоОбъектXDTO,
	ЭтоГруппа, ИскатьПоКоду, ПолнНаимен,
	Родитель, Владелец, Менеджер,
	РазмерТранзакции, Прогресс, МассивСсылок, БылиНепомеченные)
	
	// Константы
	Пробелы = "                                                  "; // 50 пробелов (для «добивки» до длины кода)
	
	// Определить, поддерживает ли данный справочник группы
	МетаданныеСправочника = Менеджер.ПустаяСсылка().Метаданные();
	ПоддерживаетГруппы =
		(МетаданныеСправочника.ВидИерархии = СвойстваОбъектовМетаданных.ВидИерархии.ИерархияГруппИЭлементов);
	
	Для Каждого Строка Из Коллекция Цикл
		
		// ЕстьПометка
		Если ЕстьПометка И Не Строка.Пометка Тогда
			БылиНепомеченные = Истина;
			Продолжить;
		КонецЕсли;
		
		// РазмерТранзакции, Прогресс
		Прогресс = Прогресс + 1;
		Если РазмерТранзакции <> 0 Тогда
			Если Прогресс % РазмерТранзакции = 0 Тогда
				ЗафиксироватьТранзакцию();
				НачатьТранзакцию();
			КонецЕсли;
		КонецЕсли;
		#Если Клиент Тогда
		ОбработкаПрерыванияПользователя();
		#КонецЕсли
		
		// ЭтоГруппа
		СоздаватьГруппу = ПоддерживаетГруппы
		                И Родитель <> Неопределено
		                И ?(ЭтоГруппа = Неопределено, Строка.ЭтоГруппа, ЭтоГруппа);
		
		
		ПоставщикЗначенийРеквизитов = ?(ЭтоОбъектXDTO, Строка, Строка.xdtoОбъект);
		
		// ИскатьПоКоду
		Если Не ЭтоОбъектXDTO Тогда
			ТекСсылка = Строка.Ссылка;
		Иначе
			СК = СвойстваОбъектовМетаданных.СерииКодовСправочника;
			ТекСсылка = Менеджер.НайтиПоКоду(ПоставщикЗначенийРеквизитов.Код, Ложь,
				?(ИскатьПоКоду = СК.ВПределахПодчинения,
					Родитель, Неопределено),
				?(ИскатьПоКоду = СК.ВПределахПодчиненияВладельцу,
					Владелец, Неопределено));
		КонецЕсли;
		Если ТекСсылка = Неопределено Тогда
			ТекСсылка = Менеджер.ПустаяСсылка();
		КонецЕсли;
		
		// Создание элемента
		Если ТекСсылка.Пустая() Тогда
			Объект = ?(СоздаватьГруппу, Менеджер.СоздатьГруппу(), Менеджер.СоздатьЭлемент());
		Иначе
			Если Родитель <> Неопределено
				И (Не ЭтоОбъектXDTO
					И Строка.ТекЭтоГруппа <> СоздаватьГруппу
					Или ЭтоОбъектXDTO
						И ТекСсылка.ЭтоГруппа <> СоздаватьГруппу) Тогда
				Объект = ?(СоздаватьГруппу, Менеджер.СоздатьГруппу(), Менеджер.СоздатьЭлемент());
				// в случае, если не все свойства устанавливаются классификатором,
				// попытаемся сохранить имеющиеся
				ЗаполнитьЗначенияСвойств(Объект, ТекСсылка, , "Владелец");
				ТекСсылка.ПолучитьОбъект().Удалить();
				Объект.УстановитьСсылкуНового(ТекСсылка)
			Иначе
				Объект = ТекСсылка.ПолучитьОбъект();
				// Если элемент справочника удалили, пока ссылка на него хранилась в дереве.
				Если Объект = Неопределено Тогда
					Объект = ?(СоздаватьГруппу, Менеджер.СоздатьГруппу(), Менеджер.СоздатьЭлемент());
					Объект.УстановитьСсылкуНового(ТекСсылка);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		Попытка
			Объект.Заблокировать();
		Исключение
			ОбщегоНазначения.СообщитьОбОшибке(КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецПопытки;
		
		Если Объект.Заблокирован() Тогда
			
			// Заполнение элемента
			Если Родитель <> Неопределено Тогда УстановитьНовоеЗначение(Объект.Родитель, Родитель) КонецЕсли;
			Если Владелец <> Неопределено Тогда УстановитьНовоеЗначение(Объект.Владелец, Владелец) КонецЕсли;
			УстановитьНовоеЗначение(Объект.ПометкаУдаления, Ложь);
			Если Не ПустаяСтрока(ПолнНаимен) Тогда
				УстановитьНовоеЗначение(Объект[ПолнНаимен], ПоставщикЗначенийРеквизитов.Наименование);
			КонецЕсли;
			
			Если Объект.Модифицированность() Или Объект.ЭтоНовый() Тогда // уже бессмысленно проверять, изменились ли значения свойств
				
				ЗаполнитьЗначенияСвойств(Объект, ПоставщикЗначенийРеквизитов);
				
			Иначе
				
				Реквизиты = МетаданныеСправочника.Реквизиты;
				Для Каждого Свойство Из ПоставщикЗначенийРеквизитов.Свойства() Цикл
					
					Если ТипЗнч(Свойство.Тип) = Тип("ТипЗначенияXDTO") Тогда
						ИмяСвойства = Свойство.Имя;
						
						Если НРег(ИмяСвойства) = "код" Или НРег(ИмяСвойства) = "code" Тогда
							Если МетаданныеСправочника.ДлинаКода > 0 Тогда
								Если МетаданныеСправочника.ТипКода = СвойстваОбъектовМетаданных.ТипКодаСправочника.Строка Тогда
									УстановитьНовоеЗначение(
										Объект.Код,
										Лев(Строка(ПоставщикЗначенийРеквизитов[ИмяСвойства]) + Пробелы, МетаданныеСправочника.ДлинаКода));
								Иначе
									УстановитьНовоеЗначение(Объект.Код, ПоставщикЗначенийРеквизитов[ИмяСвойства]);
								КонецЕсли;
							КонецЕсли;
						ИначеЕсли НРег(ИмяСвойства) = "наименование" Или НРег(ИмяСвойства) = "description" Тогда
							Если МетаданныеСправочника.ДлинаНаименования > 0 Тогда
								УстановитьНовоеЗначение(Объект.Наименование, ПоставщикЗначенийРеквизитов[ИмяСвойства]);
							КонецЕсли;
						ИначеЕсли Реквизиты.Найти(ИмяСвойства) <> Неопределено Тогда
							УстановитьНовоеЗначение(Объект[ИмяСвойства], ПоставщикЗначенийРеквизитов[ИмяСвойства]);
						КонецЕсли;
						
					КонецЕсли;
					
				КонецЦикла;
				
			КонецЕсли;
			
			Объект.ОбменДанными.Загрузка = Истина;
			Объект.ДополнительныеСвойства.Вставить("ОбъектXDTO", ПоставщикЗначенийРеквизитов);
			Объект.ДополнительныеСвойства.Вставить("ЗагрузкаКлассификаторов", Истина);
			
			Если Объект.Модифицированность() Или Объект.ЭтоНовый() Тогда
				Объект.Записать();
			КонецЕсли;
			Если МассивСсылок <> Неопределено Тогда
				МассивСсылок.Добавить(Объект.Ссылка)
			КонецЕсли;
			
		КонецЕсли; // Объект.Заблокирован()
		
		// ЕстьСтроки
		Если ЕстьСтроки Тогда
			ЗаписатьКоллекциюВСправочник(Строка.Строки,
				ЕстьПометка, Истина, ЕстьЭлементы, ЭтоОбъектXDTO,
				?(ЭтоГруппа = Неопределено, Неопределено, Истина), ИскатьПоКоду, ПолнНаимен,
				?(Родитель = Неопределено, Неопределено, Объект.Ссылка), Владелец, Менеджер,
				РазмерТранзакции, Прогресс, МассивСсылок, БылиНепомеченные);
		КонецЕсли;
		
		// ЕстьЭлементы
		Если ЕстьЭлементы И Строка.Элементы <> Неопределено Тогда
			ЗаписатьКоллекциюВСправочник(Строка.Элементы,
				Ложь, Ложь, Ложь, ЭтоОбъектXDTO,
				Ложь, ИскатьПоКоду, ПолнНаимен,
				?(Родитель = Неопределено, Неопределено, Объект.Ссылка), Владелец, Менеджер,
				РазмерТранзакции, Прогресс, МассивСсылок, БылиНепомеченные);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры // ЗаписатьКоллекциюВСправочник()

Процедура УдалитьНеактуальныеЭлементыСправочника(ИмяСправочника, Владелец, МассивАктуальных, Прогресс, РазмерТранзакции)
	
	Запрос = Новый Запрос;
	ТекстЗапроса = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
	               |	Классификатор.Ссылка КАК Ссылка
	               |ИЗ
	               |	Справочник." + ИмяСправочника + " КАК Классификатор
	               |ГДЕ
	               |	Классификатор.ПометкаУдаления = ЛОЖЬ
	               |	И (НЕ Классификатор.Ссылка В (&МассивСсылок))
	               |
	               |ДЛЯ ИЗМЕНЕНИЯ
	               |ИТОГИ
	               |	КОЛИЧЕСТВО(Ссылка)
	               |ПО
	               |	ОБЩИЕ";
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "КОСГУ", ИмяСправочника);
	Если Владелец <> Неопределено Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ГДЕ",
			"ГДЕ Классификатор.Владелец = &Владелец И");
		Запрос.УстановитьПараметр("Владелец", Владелец);
	КонецЕсли;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("МассивСсылок", МассивАктуальных);
	
	НачатьТранзакцию();
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если Не РезультатЗапроса.Пустой() Тогда
		
		ВыборкаОбщиеИтоги = РезультатЗапроса.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
		Если ВыборкаОбщиеИтоги.Следующий() Тогда
			
			// Размер прогресса задан количеством элементов к записи,
			// мы же используем индикатор заново, не меняя максимального
			// значения, поэтому определяем коэффициент.
			КоличествоНеактуальных = ВыборкаОбщиеИтоги.Ссылка;
			
			Если КоличествоНеактуальных <> 0 Тогда
				
				Выборка = ВыборкаОбщиеИтоги.Выбрать();
				
				Счетчик = 0;
				Прогресс = 0;
				ШагПрогресса = МассивАктуальных.Количество() / КоличествоНеактуальных;
				
				Пока Выборка.Следующий() Цикл
					
					Счетчик = Счетчик + 1;
					Если РазмерТранзакции <> 0 Тогда
						Если Счетчик % РазмерТранзакции = 0 Тогда
							ЗафиксироватьТранзакцию();
							НачатьТранзакцию();
						КонецЕсли;
					КонецЕсли;
					Прогресс = Прогресс + ШагПрогресса;
					
					Объект = Выборка.Ссылка.ПолучитьОбъект();
					Если Объект = Неопределено Тогда // «битая» ссылка
						Продолжить; // не знаем что с ними делать
					КонецЕсли;
					
					//Объект.ОбменДанными.Загрузка = Ложь; // это не загрузка, а удаление
					Объект.ДополнительныеСвойства.Вставить("ОбъектXDTO", Неопределено);
					Объект.ДополнительныеСвойства.Вставить("ЗагрузкаКлассификаторов", Истина);
					УстановитьНовоеЗначение(Объект.ПометкаУдаления, Истина);
					Если Объект.Модифицированность() Тогда
						Объект.Записать();
					КонецЕсли;
					
				КонецЦикла;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	ЗафиксироватьТранзакцию();
	
КонецПроцедуры

// Процедура, инициирующая сохранение классификатора из дерева значений
// или объекта XDTO в справочник. Вызывается из процедуры
// ЗаписатьКлассификаторыВФорме формы помощника.
//
// Параметры:
//  Источник     - ДеревоЗначений, ОбъектXDTO; объект-источник, содержащий
//                 классификатор;
//  ИмяСправочника - Строка; идентификатор справочника, в который нужно
//                 записать классификатор;
//  УдалятьНеактуальные - Булево; означает, что после загрузки справочника
//                 нужно пометить на удаление оставшиеся элементы. Эффективно
//                 только если загружается классификатор целиком;
//  Владелец     - Ссылка; ссылка на элемент справочника-владельца, который
//                 будет применен для всего классификатора; //!!!
//  ИмяРеквизитаПолнНаименование - Строка; идентификатор реквизита справочника-
//                 приемника, в который дополнительно к Наименованию будет
//                 записываться наименование позиции классификатора;
//  РазмерТранзакции - 0 или кол-во элементов, после обработки которого
//                 нужно фиксировать транзакцию;
//  Прогресс     - Число; переменная-реквизит формы, служащий источником
//                 данных для элемента управления Индикатор (свойство
//                 максимальное значение уже должно быть установлено).
//
Процедура СохранитьКлассификатор(Источник, ИмяСправочника, УдалятьНеактуальные, Владелец,
	ИмяРеквизитаПолнНаименование, РазмерТранзакции, Прогресс) Экспорт
	
	Перем МассивСсылок;
	
	Менеджер         = Справочники[ИмяСправочника];
	МД               = МетаданныеКонфигурации.Справочники.Найти(ИмяСправочника);
	
	ИскатьПоКоду     = МД.СерииКодов;
	Иерархический    = МД.Иерархический;
	БываютГруппы     = Иерархический
		И МД.ВидИерархии =
			 СвойстваОбъектовМетаданных.ВидИерархии.ИерархияГруппИЭлементов;
	
	Прогресс = 0;
	
	Если УдалятьНеактуальные Тогда
		МассивСсылок = Новый Массив
	КонецЕсли;
	
	НачатьТранзакцию(РежимУправленияБлокировкойДанных.Автоматический);
	Попытка
		
		ТекущееСостояние = "Сохранение классификатора в справочник «" + МД.Синоним + "»…";
		
		//ЗаписатьКоллекциюВСправочник(Коллекция,
		//	ЕстьПометка, ЕстьСтроки, ЕстьЭлементы, ЭтоОбъектXDTO
		//	ЭтоГруппа, ИскатьПоКоду, ПолнНаимен,
		//	Родитель, Владелец, Менеджер,
		//	РазмерТранзакции, Прогресс)
		
		БылиНепомеченные = Ложь;
		
		Если ТипЗнч(Источник) = Тип("ДеревоЗначений") Тогда
			
			ЗаписатьКоллекциюВСправочник(Источник.Строки,
				Истина, Истина, Источник.Колонки.Найти("Элементы") <> Неопределено, Ложь,
				?(БываютГруппы, Неопределено, Ложь), ИскатьПоКоду, ИмяРеквизитаПолнНаименование,
				?(Иерархический, Менеджер.ПустаяСсылка(), Неопределено), Владелец, Менеджер,
				РазмерТранзакции, Прогресс, МассивСсылок, БылиНепомеченные);
			
		ИначеЕсли ТипЗнч(Источник) = Тип("ОбъектXDTO")
		        И Источник.Тип().Имя = "ClassifierDataType"
		        И Источник.Тип().URIПространстваИмен = xmlnsКлассификатор Тогда
			
			ЗаписатьКоллекциюВСправочник(Источник.Строки, // <classifier>/<data>/<group>
				Ложь, Истина, Истина, Истина,
				БываютГруппы, ИскатьПоКоду, ИмяРеквизитаПолнНаименование,
				?(Иерархический, Менеджер.ПустаяСсылка(), Неопределено), Владелец, Менеджер,
				РазмерТранзакции, Прогресс, МассивСсылок, БылиНепомеченные);
			
			Если БылиНепомеченные Тогда
				// Все равно уже не будем помечать на удаление, так освободим память.
				МассивСсылок = Неопределено;
			КонецЕсли;
			
			ЗаписатьКоллекциюВСправочник(Источник.Элементы, // <classifier>/<data>/<item>
				Ложь, Ложь, Ложь, Истина,
				Ложь, ИскатьПоКоду, ИмяРеквизитаПолнНаименование,
				?(Иерархический, Менеджер.ПустаяСсылка(), Неопределено), Владелец, Менеджер,
				РазмерТранзакции, Прогресс, МассивСсылок, БылиНепомеченные);
			
		Иначе
			ВызватьИсключение "Источник не может быть сохранен в справочник."
		КонецЕсли;
		
		Если УдалятьНеактуальные И Не БылиНепомеченные Тогда
			
			ТекущееСостояние = "Помечание на удаление неактуальных элементов…";
			
			УдалитьНеактуальныеЭлементыСправочника(ИмяСправочника, Владелец, МассивСсылок,
				Прогресс, РазмерТранзакции);
			
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
		ТекущееСостояние = "";
		
	Исключение
		
		ТекущееСостояние = "";
		ВызватьИсключение;
		
	КонецПопытки;
	
	ТекущееСостояние = "";
	
КонецПроцедуры // СохранитьКлассификатор()

// Записывает в базу загруженные классификаторы.
//
// Параметры:
//  Прогресс     - Число. Значение индикатора формы прогресса.
//
Процедура ЗаписатьКлассификаторы(Прогресс = 0) Экспорт
	
	Для Каждого Классификатор Из Классификаторы Цикл
		Если Не Классификатор.Загружать Тогда
			Продолжить;
		КонецЕсли;
		
		xdtoТипКлассификатора = xdtoТипКлассификатора(Классификатор.Идентификатор);
		
		ОбъектЗагрузки = ПолучитьСодержаниеКлассификатора(Классификатор, Истина);
		
		СохранитьКлассификатор(ОбъектЗагрузки,
			xdtoТипКлассификатора.ИмяСправочника,
			Классификатор.УдалятьНеактуальные,
			Неопределено,
			xdtoТипКлассификатора.ИмяРеквизитаПолнНаименование,
			5000,
			Прогресс);
		
	КонецЦикла;
	
КонецПроцедуры

// Процедура проверяет переданный параметр, если он не соответствует значению, 
// то присваивает ему указанное значение.
//
// Параметры:
//  Параметр - параметр, значение которого проверяется и заполняется.
//  Значение - значение для заполнения пустого параметра.
//
Процедура УстановитьНовоеЗначение(Параметр, Значение) Экспорт
	
	Если Параметр <> Значение Тогда
		Параметр = Значение;
	КонецЕсли;
	
КонецПроцедуры // УстановитьНовоеЗначение()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ ПРЕОБРАЗОВАНИЯ XDTO В ДЕРЕВО ЗНАЧЕНИЙ
//

Процедура ЗаписатьXdtoСписокВКоллекцию(xdtoСписок, Коллекция, ЭтоГруппы, ЭлементыВСтроки, ТабСсылок,
	РодительСсылка, Прогресс)
	
	Для Каждого xdtoОбъект Из xdtoСписок Цикл
		Прогресс = Прогресс + 1;
		Строка = Коллекция.Добавить();
		Строка.Представление = xdtoОбъект.Код + "  " + xdtoОбъект.Наименование;
		Если ТабСсылок.Колонки.Найти("Родитель") = Неопределено Тогда
			СтрСсылки = ТабСсылок.Найти(xdtoОбъект.Код, "Код");
		ИначеЕсли РодительСсылка <> Неопределено Тогда
			МассивСтрСсылок = ТабСсылок.НайтиСтроки(Новый Структура("Родитель,Код",
				РодительСсылка, xdtoОбъект.Код));
			СтрСсылки = ?(МассивСтрСсылок.Количество() = 0, Неопределено, МассивСтрСсылок[0]);
		Иначе
			СтрСсылки = Неопределено
		КонецЕсли;
		Если СтрСсылки <> Неопределено Тогда
			Строка.Ссылка = СтрСсылки.Ссылка;
			Строка.ТекЭтоГруппа = СтрСсылки.ТекЭтоГруппа;
		КонецЕсли; 
		Если ЭлементыВСтроки Или ЭтоГруппы Тогда
			Строка.ЭтоГруппа = ЭтоГруппы;
			Строка.Пометка = Не (СтрСсылки = Неопределено Или СтрСсылки.ПометкаУдаления)
		КонецЕсли;
		Строка.xdtoОбъект = xdtoОбъект;
		Если ЭтоГруппы Тогда
			ЗаписатьXdtoСписокВКоллекцию(xdtoОбъект.Строки, Строка.Строки, Истина, ЭлементыВСтроки, ТабСсылок, 
				Строка.Ссылка, Прогресс);
			Если ЭлементыВСтроки Тогда
				КоллекцияЭлементов = Строка.Строки
			Иначе
				КоллекцияЭлементов = Новый ТаблицаЗначений;
				КоллекцияЭлементов.Колонки.Добавить("Представление");
				КоллекцияЭлементов.Колонки.Добавить("xdtoОбъект");
				КоллекцияЭлементов.Колонки.Добавить("Ссылка");
				КоллекцияЭлементов.Колонки.Добавить("ТекЭтоГруппа");
				Строка.Элементы = КоллекцияЭлементов;
			КонецЕсли; 
			ЗаписатьXdtoСписокВКоллекцию(xdtoОбъект.Элементы, КоллекцияЭлементов, Ложь, ЭлементыВСтроки, ТабСсылок,
				Строка.Ссылка, Прогресс);
		КонецЕсли; 
	КонецЦикла;
КонецПроцедуры // ЗаписатьXdtoСписокВКоллекцию()

// Процедура формирует ДеревоЗначений из переданного ОбъектаXDTO типа
// {xmlnsКлассификаторы}classifier.
//
// Параметры:
//  xdtoОбъект   - ОбъектXDTO; объект-результат чтения XML-узла <classifier>
//                 с помощью фабрики XDTO, содержащей пакет пространства имен
//                 {xmlnsКлассификаторы};
//  Дерево       - ДеревоЗначений; приемник данных, дерево должно иметь колонки
//                 Представление (строка), xdtoОбъект, Пометка (булево),
//                 ЭтоГруппа (булево), Элементы (ТаблицаЗначений);
//  Прогресс     - Число; инкрементируемая переменная (для обновления
//                 прогресс-бара).
//
Процедура ОбъектXDTOвДеревоЗначений(xdtoОбъект, Дерево, ИмяСправочника, Владелец, Прогресс)
	// Исходим из предположения, что у справочника включен контроль уникальности.
	Прогресс = 0;
	Дерево.Строки.Очистить();
	ЭлементыВСтроки = xdtoОбъект.Элементы.Количество() > 0; // если в корне есть элементы, показываем их в дереве
	ТаблицаСсылок = ПолучитьТаблицуСсылок(ИмяСправочника, Владелец);
	ЗаписатьXdtoСписокВКоллекцию(xdtoОбъект.Строки, Дерево.Строки, Истина,
		ЭлементыВСтроки, ТаблицаСсылок, Справочники[ИмяСправочника].ПустаяСсылка(), Прогресс);
	Если ЭлементыВСтроки Тогда
		ЗаписатьXdtoСписокВКоллекцию(xdtoОбъект.Элементы, Дерево.Строки, Ложь,
			Истина, ТаблицаСсылок, Справочники[ИмяСправочника].ПустаяСсылка(), Прогресс)
	КонецЕсли;
КонецПроцедуры // ОбъектXDTOвДеревоЗначений()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ ФОРМИРОВАНИЯ СПИСКА КЛАССИФИКАТОРОВ
//

// Процедура обрабатывает файл и решает, похож ли он на файл классификатора.
//
// Параметры:
//  Файл         - Файл; файл-источник;
//  ТипЧитателя  - Тип; переменная, принимающая тип объекта, который нужно
//                 создать, чтобы прочесть файл (ЧтениеXML или
//                 ЧтениеFastInfoset);
//  ПервичныйИсточник - Строка; первичное имя файла (Файл может быть
//                 временным) или URL для отображения в сообщениях об ошибках;
//  MIMEТип      - Строка; MIME-тип файла (в случае, если принят по протоколу
//                 HTTP), также используется для определения типа файла.
Функция ПроверитьРазархивироватьФайл(Файл, ТипЧитателя, ПервичныйИсточник, MIMEТип = "")
	
	Если НРег(Файл.Расширение) = ".aml" Тогда
		
		ИмяРаспакованногоФайла = ПолучитьИмяВременногоФайла("xml");
		ТекущееСостояние = "Распаковка файла " + Файл.Имя + "…";
		РаспаковкаФайла        = Новый ЧтениеТекста(Файл.Имя, КодировкаТекста.UTF8);
		Попытка
			Хранилище              = XMLЗначение(Тип("ХранилищеЗначения"), РаспаковкаФайла.Прочитать());
			ДвоичныеДанные         = Хранилище.Получить();
			ДвоичныеДанные.Записать(ИмяРаспакованногоФайла);
		Исключение
			#Если Не ВнешнееСоединение Тогда
			ОбщегоНазначения.СообщитьОбОшибке("Файл "
				+ Файл.Имя
				+ " не удалось распаковать: файл поврежден,"
				+ " имеет неверный формат, или не достаточно места на диске.");
			#КонецЕсли
			Возврат Неопределено
		КонецПопытки;
		ВременныеФайлы.Добавить(ИмяРаспакованногоФайла);
		Результат = Новый Файл(ИмяРаспакованногоФайла);
		Результат.УстановитьВремяИзменения(Файл.ПолучитьВремяИзменения());
		ТипЧитателя = Тип("ЧтениеXML");
		
	ИначеЕсли НРег(Файл.Расширение) = ".zip"
	      Или MIMEТип = "application/zip"
	      Или MIMEТип = "multipart/x-zip" Тогда
		
		ТекущееСостояние = "Распаковка файла " + Файл.Имя + "…";
		Zip = Новый ЧтениеZipФайла;
		Zip.Открыть(Файл.ПолноеИмя);
		Для Каждого Элемент Из Zip.Элементы Цикл
			Если Найти(".aml.xml.fin.finf.zip", НРег(Элемент.Расширение)) = 0
			 Или Элемент.Зашифрован Тогда
				Продолжить;
			КонецЕсли;
			ТемпКаталог = ПолучитьИмяВременногоФайла();
			Попытка
				Zip.Извлечь(Элемент, ТемпКаталог, РежимВосстановленияПутейФайловZIP.НеВосстанавливать);
			Исключение
				#Если Не ВнешнееСоединение Тогда
				ОбщегоНазначения.СообщитьОбОшибке("Файл "
					+ Элемент.Имя
					+ " не удалось извлечь из "
					+ Файл.Имя
					+ ": архив поврежден, имеет неверный формат, или"
					+ " не достаточно места на диске.");
				#КонецЕсли
				Продолжить
			КонецПопытки;
			НовоеИмя = ТемпКаталог + "\" + Элемент.Имя;
			ВременныеФайлы.Добавить(НовоеИмя);
			ВременныеФайлы.Добавить(ТемпКаталог);
			НовыйФайл = Новый Файл(НовоеИмя);
			ДобавитьКлассификатор(НовыйФайл, ПервичныйИсточник, "");
		КонецЦикла;
		Результат = Неопределено;
		
	ИначеЕсли НРег(Файл.Расширение) = ".finf"
	      Или НРег(Файл.Расширение) = ".fin"
	      Или MIMEТип = "application/fastinfoset" Тогда
		
		Результат = Файл;
		ТипЧитателя = Тип("ЧтениеFastInfoset");
		
	ИначеЕсли НРег(Файл.Расширение) = ".xml"
	      Или MIMEТип = "text/xml"
	      Или MIMEТип = "text/plain"
	      Или MIMEТип = "application/xml"
	      Или MIMEТип = "" Тогда
		
		Результат = Файл;
		ТипЧитателя = Тип("ЧтениеXML");
		
	Иначе
		
		ОбщегоНазначения.СообщитьОбОшибке("Файл " + Файл.Имя + " не является файлом классификатора.");
		Результат = Неопределено;
		
	КонецЕсли;
	
	Возврат Результат;
КонецФункции // ПроверитьРазархивироватьФайл()

Функция ДобавитьКлассификатор(СтрокаXMLИлиФайл, ПервичныйИсточник = "", MIMEТип = "") Экспорт
	
	Перем ТипЧитателя, Идентификатор, Наименование, НормАкт, Строка;
	
	ИсточникЯвляетсяФайлом = ТипЗнч(СтрокаXMLИлиФайл) = Тип("Файл");
	
	Данные = Новый Структура("Содержание,
		|ФабрикаXDTO,
		|СтрокаXMLИлиФайл,
		|ТипЧитателя,
		|ДатаМодификации,
		|КоличествоЭлементов,
		|МаксимальноеЗначениеПрогрессора");
	
	Если Не ИсточникЯвляетсяФайлом Тогда
		ЧтениеXML = Новый ЧтениеXML;
		ЧтениеXML.УстановитьСтроку(СтрокаXMLИлиФайл);
		
	Иначе
		Файл = ПроверитьРазархивироватьФайл(СтрокаXMLИлиФайл, ТипЧитателя,
			ПервичныйИсточник, MIMEТип);
		Если Файл = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли; 
		Данные.ДатаМодификации = Файл.ПолучитьВремяИзменения();
		Данные.ТипЧитателя = ТипЧитателя;
		
		ЧтениеXML = Новый(ТипЧитателя);
		Попытка
			ЧтениеXML.ОткрытьФайл(Файл.ПолноеИмя)
		Исключение
			#Если Не ВнешнееСоединение Тогда
			ОбщегоНазначения.СообщитьОбОшибке("Файл " + СтрокаXMLИлиФайл.Имя + " поврежден или имеет неверный формат.");
			#КонецЕсли
			Возврат Неопределено
		КонецПопытки;
		
	КонецЕсли;
	
	Попытка
		ЧтениеXML.ПерейтиКСодержимому();
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента
		   И ЧтениеXML.URIПространстваИмен = xmlnsКлассификатор
		   И ЧтениеXML.ЛокальноеИмя = "classifier" Тогда
			
			Идентификатор = ЧтениеXML.ЗначениеАтрибута("classifier-type-id");
			ПозицияМаркераФрагмента = Найти(Идентификатор, "#");
			
			Если ПозицияМаркераФрагмента = 0 Тогда
				Возврат Неопределено;
			КонецЕсли;
			Идентификатор = Сред(Идентификатор, ПозицияМаркераФрагмента + 1);
			
			// Узнали, что за классификатор – тут же выясняем, нужен ли он нам.
			Тип = xdtoТипКлассификатора(Идентификатор);
			
			// Неизвестного или незапрашиваемого типа.
			Если Тип = Неопределено
				Или ОтборТипов.Количество() > 0
				  И ОтборТипов.НайтиПоЗначению(Идентификатор) = Неопределено Тогда
				Возврат Неопределено;
			КонецЕсли;
			
			// Уже нашли новее.
			Строка = Классификаторы.Найти(Идентификатор, "Идентификатор");
			Если Строка <> Неопределено
			   И ДопДанные[Строка].ДатаМодификации > Данные.ДатаМодификации Тогда
				Возврат Неопределено;
			КонецЕсли; 
			
			ЗагружатьПолностью  = ЧтениеXML.ЗначениеАтрибута("allow-partial-load") = "false";
			УдалятьНеактуальные = ЧтениеXML.ЗначениеАтрибута("remove-obsolete") = "true";
			НеЧитать = Ложь;
			Пока НеЧитать Или ЧтениеXML.Прочитать() Цикл
				НеЧитать = Ложь;
				Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
					Если ЧтениеXML.ЛокальноеИмя = "additional-packages"
					   И ЧтениеXML.URIПространстваИмен = xmlnsКлассификатор Тогда
						xdtoДопМодель = xdtoПрочитать(ЧтениеXML,
							ФабрикаXDTOКлассификаторов(),
							xmlnsV8XDTO, "Model");
						Для Каждого xdtoПакет Из МассивОбщихПакетовXDTO Цикл
							xdtoДопМодель.Package.Добавить(xdtoПакет);
						КонецЦикла;
						Данные.ФабрикаXDTO = Новый ФабрикаXDTO(xdtoДопМодель);
						НеЧитать = Истина; // мы уже на начале элемента, вызывать Прочитать() не надо
						
					ИначеЕсли ЧтениеXML.ЛокальноеИмя = "legal-ref"
					        И ЧтениеXML.URIПространстваИмен = xmlnsНормАкты Тогда
						НормАкт = xdtoПрочитать(ЧтениеXML,
							ФабрикаXDTOКлассификаторов(),
							xmlnsНормАкты, "LegalRefWithRevisionsType");
						НеЧитать = Истина;
							
					ИначеЕсли ЧтениеXML.ЛокальноеИмя = "desc"
					        И ЧтениеXML.URIПространстваИмен = xmlnsКлассификатор Тогда
						ЧтениеXML.Прочитать();
						Если ЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
							Наименование = ЧтениеXML.Значение;
						КонецЕсли; 
						
					ИначеЕсли ЧтениеXML.ЛокальноеИмя = "data"
					   И ЧтениеXML.URIПространстваИмен = xmlnsКлассификатор Тогда
						Попытка
							Данные.КоличествоЭлементов = Число(ЧтениеXML.ЗначениеАтрибута("item-count"));
						Исключение
							Данные.КоличествоЭлементов = 0;
						КонецПопытки;
						Попытка
							Данные.МаксимальноеЗначениеПрогрессора = Число(ЧтениеXML.ЗначениеАтрибута("custom-progress-max-value"));
						Исключение
							Данные.МаксимальноеЗначениеПрогрессора = 0;
						КонецПопытки;
						// Если в файле не указано количество элементов, пытаемся определить его сами
						// посредством XPath. Очень долго…
						Если Данные.КоличествоЭлементов = 0 И Данные.МаксимальноеЗначениеПрогрессора = 0 Тогда
							ТекущееСостояние = "Подсчет позиций классификатора…";
							Попытка
								ПостроительDOM = Новый ПостроительDOM;
								ВремЧтениеXML  = Новый(ТипЧитателя);
								ВремЧтениеXML.ОткрытьФайл(Файл.ПолноеИмя);
								ДокументDOM = ПостроительDOM.Прочитать(ВремЧтениеXML);
								Разыменователь = Новый РазыменовательПространствИменDOM("csf", xmlnsКлассификатор);
								Результат = ДокументDOM.ВычислитьВыражениеXPath(
									"count(/csf:classifier/csf:data//csf:*[local-name()='group' or local-name()='item'])",
									ДокументDOM.ЭлементДокумента,
									Разыменователь,
									ТипРезультатаDOMXPath.Число);
								Данные.КоличествоЭлементов = Результат.ЧисловоеЗначение;
								// Освободим память.
								ДокументDOM   = Неопределено;
								ВремЧтениеXML = Неопределено;
							Исключение
							КонецПопытки;
							ТекущееСостояние = "";
						КонецЕсли; 
						Прервать;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	Исключение
		#Если Клиент Тогда
		ПоказатьИнформациюОбОшибке(ИнформацияОбОшибке());
		#КонецЕсли
		Возврат Неопределено
	КонецПопытки;
	
	Если Не ЗначениеЗаполнено(Идентификатор) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если Данные.ФабрикаXDTO = Неопределено Тогда
		Данные.ФабрикаXDTO = ФабрикаXDTOКлассификаторов()
	КонецЕсли;
	
	Если Строка = Неопределено Тогда
		Строка = Классификаторы.Добавить();
	КонецЕсли;
	
	Строка.Идентификатор           = Идентификатор;
	Строка.Загружать               = Истина;
	Строка.ЗагружатьПолностью      = ЗагружатьПолностью;
	Строка.УдалятьНеактуальные     = УдалятьНеактуальные;
	Строка.ПерезаписыватьОбъекты   = Истина;
	Строка.ПерезаписыватьЭтоГруппа = Истина;
	Строка.Источник                = ПервичныйИсточник;
	Строка.Наименование            = ?(ПустаяСтрока(Наименование),
	                                 	МетаданныеКонфигурации.Справочники.Найти(Тип.ИмяСправочника).Синоним,
	                                 	Наименование);
	
	Если НормАкт = Неопределено Тогда
		Строка.Редакция = "<не указана>";
	Иначе
		Строка.Редакция = "" + НормАкт.Вид + " " + НормАкт.ВыпустившийОрган
			+ ?(ПустаяСтрока(НормАкт.Название), "", " " + НормАкт.Название)
			+ " от " + Формат(НормАкт.ДатаОпубликования, "ДЛФ=D");
	КонецЕсли;
	
	Данные.СтрокаXMLИлиФайл = ?(ИсточникЯвляетсяФайлом, Файл, СтрокаXMLИлиФайл);
	ДопДанные.Вставить(Строка, Данные);
	
	Возврат Строка;
	
КонецФункции // ДобавитьКлассификатор()

Процедура ОпределитьДобавитьФайлы(Каталог, Маска)
	Для Каждого Файл Из НайтиФайлы(Каталог, Маска) Цикл
		ДобавитьКлассификатор(Файл, Файл.ПолноеИмя, "")
	КонецЦикла;
КонецПроцедуры // ОпределитьДобавитьФайлы()

Процедура НайтиКлассификаторыВФС(Идент, Маски)
	
	Для Каждого Каталог Из ЛокальныеКаталоги Цикл
		
		Если Не Каталог.Пометка Тогда
			Продолжить
		КонецЕсли;
		
		ТекущееСостояние = "Поиск классификаторов в папке " + Каталог.Значение + "…";
		Для Каждого Маска Из Маски Цикл
			ОпределитьДобавитьФайлы(Каталог, Маска)
		КонецЦикла;
		
	КонецЦикла;
	
	ТекущееСостояние = "";
	
КонецПроцедуры // НайтиКлассификаторыВФС()

// Функция ищет классификаторы в Интернете.
//
// Возвращаемое значение:
//
//  401 – неправильный пароль; 1 – другая ошибка (нет соединения); 0 – все
// нормально. Подразумевается, что 404 (ресурс не найден) – не ошибка
// (возвращает 0).
//
Функция НайтиКлассификаторыВИнтернете(Идент, Маски, URLs)

	Перем Соединение;
	
	ТекущееСостояние = "Подключение к серверу фирмы «1С»…";
	
	// По маскам файлов без wildcard'ов ищем также на сайте downloads.v8.1c.ru.
	Для Каждого Маска Из Маски Цикл
		
		Если Найти(Маска, "*") + Найти(Маска, "?") <> 0 Тогда
			Продолжить;
		КонецЕсли;
		
		Попытка
			СоединениеССерверомОбновлений(СерверОбновлений, Соединение, Истина);
			ИмяВременногоФайла = ПолучитьИмяВременногоФайла(Прав(Маска, 3));
			ТекущееСостояние = "Загрузка файла с " + СерверОбновлений + "…";
			Соединение.Получить(ПутьНаСервереОбновлений + Маска, ИмяВременногоФайла);
		Исключение
			Ошибка = ИнформацияОбОшибке().Причина;
			Если Ошибка.Причина <> Неопределено Тогда
				Если Найти(Ошибка.Причина.Описание, "(401)") <> 0
				 Или Найти(Ошибка.Причина.Описание, "аутентификаци") <> 0 Тогда
					Возврат 401
				ИначеЕсли Найти(Ошибка.Причина.Описание, "(404)") <> 0
				      Или Найти(Ошибка.Причина.Описание, "не обнаружен") <> 0 Тогда
					ТекущееСостояние = "";
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			Возврат 1
		КонецПопытки;
		
		ВременныеФайлы.Добавить(ИмяВременногоФайла);
		ДобавитьКлассификатор(Новый Файл(ИмяВременногоФайла), СерверОбновлений + ПутьНаСервереОбновлений + Маска, "");
		
	КонецЦикла;
	
	Для Каждого URL Из URLs Цикл
		
		КолонСлешСлеш = Найти(URL, "://");
		Если КолонСлешСлеш <> 0 Тогда
			Протокол = Лев(URL, КолонСлешСлеш - 1);
			URL      = Сред(URL, КолонСлешСлеш + 3);
		Иначе
			Протокол = "http";
		КонецЕсли;
		
		Если Найти(Протокол, "http") = 0 Тогда
			Продолжить;
		КонецЕсли; 
		
		Слеш = Найти(URL, "/");
		Если Слеш = 0 Тогда
			Сервер = URL;                Путь = "/";
		Иначе
			Сервер = Лев(URL, Слеш - 1); Путь = Сред(URL, Слеш);
		КонецЕсли; 
		
		Попытка
			СоединениеССерверомОбновлений(Сервер, Соединение, Ложь, Протокол = "https");
			ИмяВременногоФайла = ПолучитьИмяВременногоФайла(Прав(Путь, 3));
			ТекущееСостояние = "Загрузка файла с " + Сервер + "…";
			Соединение.Получить(Путь);
		Исключение
			Ошибка = ИнформацияОбОшибке().Причина;
			Если Ошибка.Причина <> Неопределено Тогда
				Если Найти(Ошибка.Причина.Описание, "(401)") <> 0 Тогда
					Возврат 401
				ИначеЕсли Найти(Ошибка.Причина.Описание, "(404)") <> 0 Тогда
					ТекущееСостояние = "";
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			Возврат 1
		КонецПопытки;
		
		ДобавитьКлассификатор(Новый Файл(ИмяВременногоФайла), URL, "");
		
	КонецЦикла;
	
	ТекущееСостояние = "";
	Возврат 0;
	
КонецФункции // НайтиКлассификаторыВИнтернете()

Процедура НайтиКлассификаторыНаИТС(Идент, Маски)

	Перем ГотовыеПриводы;
	
	ТекущееСостояние = "Поиск на диске «ИТС»…";
	ОпределитьУстройстваЧтенияКД(ГотовыеПриводы);
	Для Сч = 1 По СтрДлина(ГотовыеПриводы) Цикл
		Для Каждого Маска Из Маски Цикл
			ОпределитьДобавитьФайлы(Сред(ГотовыеПриводы, Сч) + ":\1CITS\EXE\EXTDB", Маска);
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры // НайтиКлассификаторыНаИТС()

Функция ВыполнитьПоиск(Источник, Идент, Маски, URLs)
	Если Источник = 1 Тогда
		Возврат НайтиКлассификаторыВИнтернете(Идент, Маски, URLs);
	ИначеЕсли Источник = 2 Тогда
		НайтиКлассификаторыНаИТС(Идент, Маски);
		Возврат 0;
	ИначеЕсли Источник = 3 Тогда
		НайтиКлассификаторыВФС(Идент, Маски);
		Возврат 0;
	КонецЕсли;
КонецФункции // ВыполнитьПоиск() 

// Функция инициирует поиск классификаторов в заданном источнике.
//
// Параметры:
//  Источник     - Число. 1 – Интернет; 2 – ИТС; 3 – файловая система.
//
// Возвращаемое значение:
//  401 – ошибка авторизации; 0 – нет ошибки; иначе – другая ошибка.
//
Функция ВыполнитьПоискВИсточнике(Источник) Экспорт
	
	Результат = 0;
	
	
	Если ОтборТипов.Количество() <> 0 Тогда
		Для Каждого Идент Из ОтборТипов Цикл
			Тип = xdtoТипКлассификатора(Идент);
			Если Тип <> Неопределено Тогда
				Результат = ВыполнитьПоиск(Источник, Идент, Тип.МаскиФайлов, Тип.URLs); 
				
				Если (Результат <> 0) Тогда
					Прервать;
				КонецЕсли;
			КонецЕсли; 
		КонецЦикла
	Иначе
		Для Каждого Тип Из xdtoТипыКлассификаторов().ТипыКлассификаторов Цикл
			Результат = ВыполнитьПоиск(Источник, Тип.xmlid, Тип.МаскиФайлов, Тип.URLs); 
			
			Если (Результат <> 0) Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли; 

	
	Возврат Результат;
КонецФункции // ВыполнитьПоискВИсточнике()

////////////////////////////////////////////////////////////////////////////////
// ПРОЧИЕ ЭКСПОРТНЫЕ ПРОЦЕДУРЫ
//

// Функция получения содержимого классификатора.
//
// Параметры:
//  Строка       - ВнешняяОбработкаТабличнаяЧастьСтрока.
//                 УниверсальнаяЗагрузкаКлассификаторов.Классификаторы; строка
//                 таб. части, содержащая описание классификатора, чье
//                 содержимое нужно получить;
//  ЧитатьПринудительно - Булево; если классификатор до сих пор не был
//                 прочитан, определяет, нужно ли его читать сейчас.
//
// Возвращаемое значение:
//  Неопределено - в случае, если ЧитатьПринудительно – Ложь, и классификатор
//                 до сих пор не был прочитан;
//  ОбъектXDTO   - объект XDTO считывается при первом требовании;
//  ДеревоЗначений - если объект XDTO уже был преобразован в ДеревоЗначений.
//
Функция ПолучитьСодержаниеКлассификатора(Строка, ЧитатьПринудительно = Ложь) Экспорт
	Данные = ДопДанные[Строка];
	Если Данные = Неопределено Тогда
		Возврат Неопределено // не может такого быть
	КонецЕсли;
	Если Данные.Содержание = Неопределено Тогда
		Если Не ЧитатьПринудительно Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		ТекущееСостояние = "Чтение содержимого классификатора " + Строка.Наименование + "…";
		Если ТипЗнч(Данные.СтрокаXMLИлиФайл) = Тип("Строка") Тогда
			ЧтениеXML = Новый ЧтениеXML;
			ЧтениеXML.УстановитьСтроку(Данные.СтрокаXMLИлиФайл)
		Иначе
			ЧтениеXML = Новый(Данные.ТипЧитателя);
			ЧтениеXML.ОткрытьФайл(Данные.СтрокаXMLИлиФайл.ПолноеИмя);
		КонецЕсли; 
		ЧтениеXML.ПерейтиКСодержимому();
		ЧтениеXML.Прочитать(); //classifier
		Пока ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента
		 Или ЧтениеXML.Прочитать() Цикл
			Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
				Если ЧтениеXML.URIПространстваИмен = xmlnsКлассификатор
				   И ЧтениеXML.ЛокальноеИмя = "data" Тогда
					
					Данные.Содержание = xdtoПрочитать(ЧтениеXML,
						Данные.ФабрикаXDTO,
						xmlnsКлассификатор, "ClassifierDataType");
					
				Иначе
					ЧтениеXML.Пропустить();
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		ТекущееСостояние = "";
	КонецЕсли;
	Возврат Данные.Содержание
КонецФункции // ПолучитьСодержаниеКлассификатора() 

// Функция возвращает дерево классификатора.  Если он еще не был преобразован в
// дерево, преобразует ОбъектXDTO в дерево.  Если он вообще еще не был считан,
// предварительно читает его в объект XDTO.
//
// Параметры:
//  Строка       - ВнешняяОбработкаТабличнаяЧастьСтрока.
//                 УниверсальнаяЗагрузкаКлассификаторов.Классификаторы; строка
//                 таб. части, содержащая описание классификатора, чье
//                 содержимое нужно получить;
//  Прогресс     - Число; инкрементируемая переменная (для обновления
//                 прогресс-бара).
//
// Возвращаемое значение:
//  ДеревоЗначений.
//
Функция ПолучитьДеревоКлассификатора(Строка, Прогресс) Экспорт
	Прогресс = 0;
	ТекСодержание = ПолучитьСодержаниеКлассификатора(Строка, Истина);
	Если Тип(ТекСодержание) = Тип("ДеревоЗначений") Тогда
		Прогресс = ДопДанные[Строка].КоличествоЭлементов;
		Возврат ТекСодержание
	Иначе
		Дерево = Новый ДеревоЗначений;
		Дерево.Колонки.Добавить("Пометка", Новый ОписаниеТипов("Булево"));
		Дерево.Колонки.Добавить("Представление");
		Дерево.Колонки.Добавить("ЭтоГруппа", Новый ОписаниеТипов("Булево"));
		Дерево.Колонки.Добавить("Элементы");
		Дерево.Колонки.Добавить("xdtoОбъект");
		Дерево.Колонки.Добавить("Ссылка");
		Дерево.Колонки.Добавить("ТекЭтоГруппа");
		
		ОбъектXDTOвДеревоЗначений(ТекСодержание, Дерево,
			xdtoТипКлассификатора(Строка.Идентификатор).ИмяСправочника,
			Неопределено, //!!! Владелец?
			Прогресс);
		ДопДанные[Строка].Содержание = Дерево;
		Возврат Дерево;
	КонецЕсли;
КонецФункции // ПолучитьДеревоКлассификатора()

Функция КоличествоЭлементов(СтрокаДерева)
	Результат = 0;
	Для Каждого Строка Из СтрокаДерева.Строки Цикл
		Если Строка.Пометка Тогда
			Результат = Результат + КоличествоЭлементов(Строка)
				+ ?(Строка.Элементы = Неопределено, 0, Строка.Элементы.Количество());
		КонецЕсли;
	КонецЦикла;
	Возврат Результат;
КонецФункции // КоличествоПометокУЭлементов() 

// Функция считает пометки в дереве, включая пометки в таблицах значений в
// колонке Элементы у помеченных строк дерева.
//
Функция КоличествоПометок(Дерево) Экспорт
	Возврат Дерево.Строки.Итог("Пометка", Истина)
		+ КоличествоЭлементов(Дерево)
КонецФункции // КоличествоПометок() 

// Удаляет временные файлы.
//
Процедура УдалитьВременныеФайлы() Экспорт
	Для Каждого ВременныйФайл Из ВременныеФайлы Цикл
		Попытка
			УдалитьФайлы(ВременныйФайл);
		Исключение
		КонецПопытки;
	КонецЦикла;
	ВременныеФайлы.Очистить();
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ОПЕРАТОРЫ ОСНОВНОЙ ПРОГРАММЫ
//

xmlnsXML                = "http://www.w3.org/XML/1998/namespace";
xmlnsV8XDTO             = "http://v8.1c.ru/8.1/xdto";
xmlnsОписанияТиповКлассификаторов = "urn:uuid:101fa9a0-ea86-11dc-afc4-0002a5d5c51b";
xmlnsКлассификатор      = "urn:uuid:be515360-d4a7-11dc-8abf-0002a5d5c51b";
xmlnsНормАкты           = "urn:uuid:4c9a8080-e11c-11dc-a7e6-0002a5d5c51b";

СерверОбновлений        = "downloads.v8.1c.ru";
ПутьНаСервереОбновлений = "/tmplts/ITS/classifiers/";

ДопДанные = Новый Соответствие;

// Запоминаем временные файлы, чтобы стереть по окончании работы.
ВременныеФайлы = Новый Массив;

МетаданныеКонфигурации = Метаданные;
СвойстваОбъектовМетаданных = МетаданныеКонфигурации.СвойстваОбъектов;
